import os
import uuid
import datetime
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, ContextTypes,
    ConversationHandler,
    CallbackQueryHandler # <--- рдпрд╣ рдЗрдореНрдкреЛрд░реНрдЯ рдХрд┐рдпрд╛ рдЧрдпрд╛ рд╣реИ
)
from pymongo import MongoClient
from flask import Flask
import threading

# --- Configuration ---
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
# рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ рдпрд╣ рдЖрдкрдХреЗ PUBLIC рдЪреИрдирд▓ рдХрд╛ рдпреВрдЬрд╝рд░рдиреЗрдо рд╣реИ (рдмрд┐рдирд╛ @ рдХреЗ)
PUBLIC_CHANNEL_USERNAME = os.getenv("PUBLIC_CHANNEL_USERNAME")
# PUBLIC_CHANNEL_ID рдХреЛ рд╣рдореЗрд╢рд╛ int рдореЗрдВ рдмрджрд▓реЗрдВ
PUBLIC_CHANNEL_ID = int(os.getenv("PUBLIC_CHANNEL_ID")) 

# рдЖрдкрдХрд╛ External API (Google Apps Script) рдмреЗрд╕ URL
EXTERNAL_API_BASE_URL = os.getenv("EXTERNAL_API_BASE_URL") # <-- рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ Koyeb рдкрд░ рдпрд╣ ENV VAR рд╕реЗрдЯ рд╣реИ

# рдЖрдкрдХрд╛ Updates Channel Link
UPDATES_CHANNEL_LINK = "https://t.me/asbhai_bsr" # <-- рдпрд╣ рд▓рд┐рдВрдХ рдЕрдм рд╕рд╣реА рд╣реИ

# MongoDB Configuration
MONGO_URI = os.getenv("MONGO_URI")
client = MongoClient(MONGO_URI)
db = client.file_bot # рдЖрдкрдХрд╛ рдбреЗрдЯрд╛рдмреЗрд╕ рдирд╛рдо
files_collection = db.files # рдЖрдкрдХрд╛ рдХрд▓реЗрдХреНрд╢рди рдирд╛рдо
# рдмреИрдЪ рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рдЕрд╕реНрдерд╛рдпреА рд╕реНрдЯреЛрд░реЗрдЬ рдкреНрд░рддрд┐ рдпреВрдЬрд╝рд░
# Key: user_id, Value: list of tokens
batch_files_in_progress = {} 

# --- Conversation States for Batch Command ---
SENDING_BATCH_FILES = 1

# --- Flask App for Health Check ---
flask_app = Flask(__name__)

@flask_app.route('/health')
def health_check():
    """
    Koyeb рдЬреИрд╕реЗ рдбрд┐рдкреНрд▓реЙрдпрдореЗрдВрдЯ рдкреНрд▓реЗрдЯрдлрд╝реЙрд░реНрдо рджреНрд╡рд╛рд░рд╛ рдЙрдкрдпреЛрдЧ рдХреЗ рд▓рд┐рдП рдПрдХ рд╕рд╛рдзрд╛рд░рдг рд╣реЗрд▓реНрде рдЪреЗрдХ рдПрдВрдбрдкреЙрдЗрдВрдЯред
    рдпрд╣ рдкреБрд╖реНрдЯрд┐ рдХрд░рддрд╛ рд╣реИ рдХрд┐ рд╡реЗрдм рд╕рд░реНрд╡рд░ рдЪрд▓ рд░рд╣рд╛ рд╣реИред
    """
    return "Bot is healthy!", 200

def run_flask_app():
    """
    Flask рдПрдкреНрд▓рд┐рдХреЗрд╢рди рдХреЛ рдПрдХ рдЕрд▓рдЧ рдереНрд░реЗрдб рдореЗрдВ рдЪрд▓рд╛рдиреЗ рдХреЗ рд▓рд┐рдП рдлрд╝рдВрдХреНрд╢рдиред
    рдпрд╣ рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░рддрд╛ рд╣реИ рдХрд┐ рдмреЙрдЯ рдХрд╛ `run_polling` рдмреНрд▓реЙрдХ рди рд╣реЛред
    """
    # рдкреЛрд░реНрдЯ рдХреЛ рдкрд░реНрдпрд╛рд╡рд░рдг рд╡реЗрд░рд┐рдПрдмрд▓ рд╕реЗ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ, рдбрд┐рдлрд╝реЙрд▓реНрдЯ 8000
    port = int(os.getenv("PORT", 8000))
    flask_app.run(host='0.0.0.0', port=port)

# --- Bot Handlers ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    args = context.args # /start рдХрдорд╛рдВрдб рд╕реЗ рдкреИрд░рд╛рдореАрдЯрд░ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ

    if args:
        param = args[0]
        if param.startswith("download_"):
            # рдпрд╣ рдмрд╛рд╣рд░реА API рд╕реЗ рдкреНрд░рд╛рдкреНрдд рдХреЙрд▓ рдмреИрдХ рд╣реИ
            original_token = param[len("download_"):]
            
            # MongoDB рд╕реЗ рдлрд╝рд╛рдЗрд▓ рдЬрд╛рдирдХрд╛рд░реА рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВ
            file_data = files_collection.find_one({"token": original_token})

            if file_data:
                # 5 рдорд┐рдирдЯ рдХреА рд╡реИрдзрддрд╛ рдХреА рдЬрд╛рдБрдЪ рдХрд░реЗрдВ
                upload_time = file_data.get("upload_time")
                # 300 рд╕реЗрдХрдВрдб = 5 рдорд┐рдирдЯ
                if upload_time and (datetime.datetime.now() - upload_time).total_seconds() > 300: 
                    await update.message.reply_text(
                        "рдпрд╣ рдбрд╛рдЙрдирд▓реЛрдб рд▓рд┐рдВрдХ рд╕рдорд╛рдкреНрдд рд╣реЛ рдЧрдИ рд╣реИред рдХреГрдкрдпрд╛ рдПрдХ рдирдИ рд▓рд┐рдВрдХ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдлрд╝рд╛рдЗрд▓ рдХреЛ рдлрд┐рд░ рд╕реЗ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВред"
                    )
                    # DB рд╕реЗ рд╕рдорд╛рдкреНрдд рдЯреЛрдХрди рдХреЛ рд╣рдЯрд╛рдПрдБ
                    files_collection.delete_one({"token": original_token}) 
                    return

                # рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ рдлрд╝рд╛рдЗрд▓ рд╕рд╣реА рдпреВрдЬрд╝рд░ (рдЬрд┐рд╕рдиреЗ рдбрд╛рдЙрдирд▓реЛрдб рд╢реБрд░реВ рдХрд┐рдпрд╛ рдерд╛) рдХреЛ рднреЗрдЬреА рдЧрдИ рд╣реИ
                if update.effective_chat.id != file_data.get("user_chat_id"):
                    await update.message.reply_text("рдпрд╣ рдлрд╝рд╛рдЗрд▓ рдЖрдкрдХреЗ рд▓рд┐рдП рдирд╣реАрдВ рд╣реИ, рдпрд╛ рд▓рд┐рдВрдХ рдЕрдорд╛рдиреНрдп рд╣реИред")
                    return

                # рд╡рд╛рд╕реНрддрд╡рд┐рдХ рдлрд╝рд╛рдЗрд▓ рднреЗрдЬреЗрдВ
                telegram_file_id = file_data["telegram_file_id"]
                original_filename = file_data["original_filename"]
                try:
                    # рдлрд╝рд╛рдЗрд▓ рдХреЗ рдкреНрд░рдХрд╛рд░ рдХреЗ рдЕрдиреБрд╕рд╛рд░ рднреЗрдЬреЗрдВ
                    if file_data.get("file_type") == "video": 
                        await update.message.reply_video(
                            video=telegram_file_id,
                            caption=f"рдпрд╣рд╛рдБ рдЖрдкрдХреА рд╡реАрдбрд┐рдпреЛ рд╣реИ: {original_filename}",
                            filename=original_filename
                        )
                    else: # рдЕрдиреНрдп рдкреНрд░рдХрд╛рд░реЛрдВ рдХреЗ рд▓рд┐рдП рдбрд┐рдлрд╝реЙрд▓реНрдЯ рд░реВрдк рд╕реЗ рдбреЙрдХреНрдпреВрдореЗрдВрдЯ
                        await update.message.reply_document(
                            document=telegram_file_id,
                            caption=f"рдпрд╣рд╛рдБ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╣реИ: {original_filename}",
                            filename=original_filename
                        )
                    # рд╡реИрдХрд▓реНрдкрд┐рдХ рд░реВрдк рд╕реЗ рд╕рдлрд▓ рдбрд╛рдЙрдирд▓реЛрдб рдХреЗ рдмрд╛рдж рдЯреЛрдХрди рд╣рдЯрд╛рдПрдБ
                    # files_collection.delete_one({"token": original_token})
                except Exception as e:
                    await update.message.reply_text(f"рдХреНрд╖рдорд╛ рдХрд░реЗрдВ, рдлрд╝рд╛рдЗрд▓ рдирд╣реАрдВ рднреЗрдЬреА рдЬрд╛ рд╕рдХреАред рдПрдХ рддреНрд░реБрдЯрд┐ рд╣реБрдИ: {e}")
            else:
                await update.message.reply_text("рдЕрдорд╛рдиреНрдп рдпрд╛ рд╕рдорд╛рдкреНрдд рдбрд╛рдЙрдирд▓реЛрдб рдЕрдиреБрд░реЛрдзред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ рдпрд╛ рдПрдХ рдирдИ рдлрд╝рд╛рдЗрд▓ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВред")
        else:
            # рдпрджрд┐ /start рдХрдорд╛рдВрдб рдХреЛ рд╕реАрдзреЗ рдХреЛрдИ рдЯреЛрдХрди рдорд┐рд▓рддрд╛ рд╣реИ рдЬреЛ рдбрд╛рдЙрдирд▓реЛрдб_ рд╕реЗ рд╢реБрд░реВ рдирд╣реАрдВ рд╣реЛрддрд╛
            await send_welcome_message(update, context) 
    else:
        # рдмрд┐рдирд╛ рдбреАрдк рд▓рд┐рдВрдХ рдХреЗ рдорд╛рдирдХ /start рдХрдорд╛рдВрдб
        await send_welcome_message(update, context)

async def send_welcome_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    keyboard = [
        [InlineKeyboardButton("Updates Channel", url=UPDATES_CHANNEL_LINK)],
        [InlineKeyboardButton("Help", callback_data="help_command")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # рдпрджрд┐ рдЕрдкрдбреЗрдЯ рдПрдХ рдореИрд╕реЗрдЬ рд╣реИ
    if update.message:
        await update.message.reply_text(
            "ЁЯСЛ рдирдорд╕реНрддреЗ! рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рд╡рд╛рд▓рд╛ рдмреЙрдЯ рд╣реВрдБред рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдпреЛрдЧреНрдп рд▓рд┐рдВрдХ рдмрдирд╛рдиреЗ рдореЗрдВ рдЖрдкрдХреА рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБред",
            reply_markup=reply_markup
        )
    # рдпрджрд┐ рдЕрдкрдбреЗрдЯ рдПрдХ рдХреЙрд▓рдмреИрдХ рдХреНрд╡реЗрд░реА (рдЬреИрд╕реЗ /start рдХрдорд╛рдВрдб рдХреЗ рдмрд╛рдж 'Back' рдмрдЯрди) рд╣реИ
    elif update.callback_query:
        await update.callback_query.message.edit_text(
            "ЁЯСЛ рдирдорд╕реНрддреЗ! рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рд╡рд╛рд▓рд╛ рдмреЙрдЯ рд╣реВрдБред рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдпреЛрдЧреНрдп рд▓рд┐рдВрдХ рдмрдирд╛рдиреЗ рдореЗрдВ рдЖрдкрдХреА рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБред",
            reply_markup=reply_markup
        )


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # рдЬрд╛рдБрдЪ рдХрд░реЗрдВ рдХрд┐ рдХреНрдпрд╛ рдпрд╣ рдХреЙрд▓рдмреИрдХ рдХреНрд╡реЗрд░реА рд╕реЗ рд╣реИ рдпрд╛ рд╕реАрдзреЗ рдХрдорд╛рдВрдб рд╕реЗ
    if update.callback_query:
        await update.callback_query.answer() # рдХреЙрд▓рдмреИрдХ рд╕реНрд╡реАрдХрд╛рд░ рдХрд░реЗрдВ
        chat_id = update.callback_query.message.chat_id
        message_id = update.callback_query.message.message_id
        
        help_text = (
            "рдпрд╣рд╛рдБ рд╡реЗ рдХрдорд╛рдВрдб рджрд┐рдП рдЧрдП рд╣реИрдВ рдЬрд┐рдирдХрд╛ рдЖрдк рдЙрдкрдпреЛрдЧ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВ:\n\n"
            "тЮбя╕П /start - рд╕реНрд╡рд╛рдЧрдд рд╕рдВрджреЗрд╢ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВред\n"
            "тЮбя╕П /link - рдПрдХ рдлрд╝рд╛рдЗрд▓ рдХреЗ рд▓рд┐рдП рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдпреЛрдЧреНрдп рд▓рд┐рдВрдХ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВред\n"
            "тЮбя╕П /batch - рдПрдХ рд╕рд╛рде рдХрдИ рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВред\n\n"
            "рдХрдорд╛рдВрдб /link рдпрд╛ /batch рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рдХреЗ рдмрд╛рдж рдореБрдЭреЗ рдХреЛрдИ рднреА рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рд╡реАрдбрд┐рдпреЛ рднреЗрдЬреЗрдВред"
        )
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=help_text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("рдкреАрдЫреЗ", callback_data="back_to_welcome")]]) # рд╡рд╛рдкрд╕ рдЬрд╛рдиреЗ рд╡рд╛рд▓рд╛ рдмрдЯрди рдЬреЛрдбрд╝реЗрдВ
        )
    else: # рдпрджрд┐ рдпрд╣ рдПрдХ рд╕реАрдзрд╛ /help рдХрдорд╛рдВрдб рд╣реИ
        help_text = (
            "рдпрд╣рд╛рдБ рд╡реЗ рдХрдорд╛рдВрдб рджрд┐рдП рдЧрдП рд╣реИрдВ рдЬрд┐рдирдХрд╛ рдЖрдк рдЙрдкрдпреЛрдЧ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВ:\n\n"
            "тЮбя╕П /start - рд╕реНрд╡рд╛рдЧрдд рд╕рдВрджреЗрд╢ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВред\n"
            "тЮбя╕П /link - рдПрдХ рдлрд╝рд╛рдЗрд▓ рдХреЗ рд▓рд┐рдП рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдпреЛрдЧреНрдп рд▓рд┐рдВрдХ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВред\n"
            "тЮбя╕П /batch - рдПрдХ рд╕рд╛рде рдХрдИ рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВред\n\n"
            "рдХрдорд╛рдВрдб /link рдпрд╛ /batch рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рдХреЗ рдмрд╛рдж рдореБрдЭреЗ рдХреЛрдИ рднреА рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рд╡реАрдбрд┐рдпреЛ рднреЗрдЬреЗрдВред"
        )
        await update.message.reply_text(help_text)

async def back_to_welcome(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    await update.callback_query.answer()
    await send_welcome_message(update, context) # рд╕реНрд╡рд╛рдЧрдд рд╕рдВрджреЗрд╢ рдХреЛ рдлрд┐рд░ рд╕реЗ рднреЗрдЬреЗрдВ (рдпрд╣ edit_text рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░реЗрдЧрд╛)

# --- Single File Link Generation ---
async def link_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    context.user_data['current_mode'] = 'single_file' # handle_file рдХреЗ рд▓рд┐рдП рдореЛрдб рд╕реЗрдЯ рдХрд░реЗрдВ
    await update.message.reply_text("рдХреГрдкрдпрд╛ рдореБрдЭреЗ рд╡рд╣ рдлрд╝рд╛рдЗрд▓ (рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рд╡реАрдбрд┐рдпреЛ) рднреЗрдЬреЗрдВ рдЬрд┐рд╕рдХреА рдЖрдк рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВред")

# --- Batch File Link Generation ---
async def batch_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    batch_files_in_progress[user_id] = [] # рдмреИрдЪ рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд╕реВрдЪреА рдХреЛ рдЗрдирд┐рд╢рд┐рдпрд▓рд╛рдЗрдЬрд╝ рдХрд░реЗрдВ
    context.user_data['current_mode'] = 'batch_file' # handle_file рдХреЗ рд▓рд┐рдП рдореЛрдб рд╕реЗрдЯ рдХрд░реЗрдВ

    keyboard = [[InlineKeyboardButton("рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ", callback_data="generate_batch_links")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "рдареАрдХ рд╣реИ, рдореБрдЭреЗ рдПрдХ-рдПрдХ рдХрд░рдХреЗ рдлрд╝рд╛рдЗрд▓реЗрдВ (рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рд╡реАрдбрд┐рдпреЛ) рднреЗрдЬреЗрдВред "
        "рдЬрдм рдЖрдк рдкреВрд░рд╛ рдХрд░ рд▓реЗрдВ, рддреЛ 'рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ' рдмрдЯрди рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред",
        reply_markup=reply_markup
    )
    return SENDING_BATCH_FILES # рдмрд╛рддрдЪреАрдд рдХреА рд╕реНрдерд┐рддрд┐ рдореЗрдВ рдкреНрд░рд╡реЗрд╢ рдХрд░реЗрдВ

async def handle_batch_file_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    if user_id not in batch_files_in_progress:
        # рдпрджрд┐ рдпреВрдЬрд╝рд░ рдмреИрдЪ рд╢реБрд░реВ рдХрд┐рдП рдмрд┐рдирд╛ рдлрд╝рд╛рдЗрд▓ рднреЗрдЬрддрд╛ рд╣реИ, рддреЛ рдЗрд╕реЗ рдПрдХрд▓ рдлрд╝рд╛рдЗрд▓ рдХреЗ рд░реВрдк рдореЗрдВ рдорд╛рдиреЗрдВ
        return await handle_file(update, context) # рдПрдХрд▓ рдлрд╝рд╛рдЗрд▓ рдкрд░ рдлрд╝реЙрд▓рдмреИрдХ

    file = None
    file_type = ""
    if update.message.document:
        file = update.message.document
        file_type = "document"
    elif update.message.video:
        file = update.message.video
        file_type = "video"
    else:
        await update.message.reply_text("рдХреГрдкрдпрд╛ рдПрдХ рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рдПрдХ рд╡реАрдбрд┐рдпреЛ рднреЗрдЬреЗрдВред рдЕрдиреНрдп рдлрд╝рд╛рдЗрд▓ рдкреНрд░рдХрд╛рд░ рдмреИрдЪ рдХреЗ рд▓рд┐рдП рд╕рдорд░реНрдерд┐рдд рдирд╣реАрдВ рд╣реИрдВред")
        return

    original_filename = file.file_name if file.file_name else f"unnamed_{file_type}"
    user_chat_id = update.message.chat_id

    try:
        sent_message = await context.bot.forward_message(
            chat_id=PUBLIC_CHANNEL_ID,
            from_chat_id=user_chat_id,
            message_id=update.message.message_id
        )
        permanent_telegram_file_id = None
        if sent_message.document:
            permanent_telegram_file_id = sent_message.document.file_id
        elif sent_message.video:
            permanent_telegram_file_id = sent_message.video.file_id
        
        if not permanent_telegram_file_id:
            await update.message.reply_text("рдлрд╝реЙрд░рд╡рд░реНрдбреЗрдб рдореИрд╕реЗрдЬ рд╕реЗ рдлрд╝рд╛рдЗрд▓ ID рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред")
            return

    except Exception as e:
        await update.message.reply_text(f"рд╕реНрдЯреЛрд░реЗрдЬ рдЪреИрдирд▓ рдкрд░ рдлрд╝рд╛рдЗрд▓ рдлрд╝реЙрд░рд╡рд░реНрдб рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: {e}")
        return

    unique_token = str(uuid.uuid4())

    file_info = {
        "token": unique_token,
        "telegram_file_id": permanent_telegram_file_id,
        "original_filename": original_filename,
        "user_chat_id": user_chat_id,
        "upload_time": datetime.datetime.now(),
        "file_type": file_type
    }
    files_collection.insert_one(file_info)

    # рдпреВрдЬрд╝рд░ рдХреА рдмреИрдЪ рд╕реВрдЪреА рдореЗрдВ рдЯреЛрдХрди рд╕реНрдЯреЛрд░ рдХрд░реЗрдВ
    batch_files_in_progress[user_id].append(unique_token)

    keyboard = [[InlineKeyboardButton("рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ", callback_data="generate_batch_links")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "рдлрд╝рд╛рдЗрд▓ рдкреНрд░рд╛рдкреНрдд рд╣реБрдИ! рдЕрдзрд┐рдХ рдлрд╝рд╛рдЗрд▓реЗрдВ рднреЗрдЬреЗрдВ рдпрд╛ рд╕рдорд╛рдкреНрдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП 'рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ' рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред",
        reply_markup=reply_markup
    )
    return SENDING_BATCH_FILES # рдЙрд╕реА рд╕реНрдерд┐рддрд┐ рдореЗрдВ рд░рд╣реЗрдВ


# MarkdownV2 рд╕реНрдкреЗрд╢рд▓ рдХреИрд░реЗрдХреНрдЯрд░ рдХреЛ рдПрд╕реНрдХреЗрдк рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рд╕рд╣рд╛рдпрдХ рдлрд╝рдВрдХреНрд╢рди
def escape_markdown_v2(text: str) -> str:
    # рдХреЗрд╡рд▓ рд╡реЗ рдХреИрд░реЗрдХреНрдЯрд░ рдПрд╕реНрдХреЗрдк рдХрд░реЗрдВ рдЬреЛ MarkdownV2 рдореЗрдВ рд╡рд┐рд╢реЗрд╖ рдЕрд░реНрде рд░рдЦрддреЗ рд╣реИрдВ
    # рдФрд░ рдЬреЛ рдЖрдкрдХреЗ literal text рдореЗрдВ рдЖ рд╕рдХрддреЗ рд╣реИрдВред
    # URL рдХреЗ рдЕрдВрджрд░ рдХреЗ рдХреИрд░реЗрдХреНрдЯрд░ рдХреЛ рдПрд╕реНрдХреЗрдк рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рдирд╣реАрдВ рд╣реЛрддреА,
    # рдХреЗрд╡рд▓ рдбрд┐рд╕реНрдкреНрд▓реЗ рдЯреЗрдХреНрд╕реНрдЯ рдореЗрдВред
    escape_chars = r'_*[]()~`>#+-=|{}.!' # рд╡реЗ рдХреИрд░реЗрдХреНрдЯрд░ рдЬрд┐рдиреНрд╣реЗрдВ рдПрд╕реНрдХреЗрдк рдХрд░рдирд╛ рдЪрд╛рд╣рд┐рдП
    return ''.join(['\\' + char if char in escape_chars else char for char in text])


async def generate_batch_links(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.callback_query.answer("рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░ рд░рд╣рд╛ рд╣реВрдБ...")
    user_id = update.effective_user.id
    
    if user_id not in batch_files_in_progress or not batch_files_in_progress[user_id]:
        await update.callback_query.message.reply_text("рдХреЛрдИ рдлрд╝рд╛рдЗрд▓реЗрдВ рдирд╣реАрдВ рдорд┐рд▓реАрдВ рдЬрд┐рдирдХреЗ рд▓рд┐рдП рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХреА рдЬрд╛ рд╕рдХреЗрдВред рдХреГрдкрдпрд╛ рдкрд╣рд▓реЗ рдлрд╝рд╛рдЗрд▓реЗрдВ рднреЗрдЬреЗрдВред")
        return ConversationHandler.END # рдмрд╛рддрдЪреАрдд рдЦрддреНрдо рдХрд░реЗрдВ
    
    links_text = "рдпрд╣рд╛рдБ рдЖрдкрдХреА рдбрд╛рдЙрдирд▓реЛрдб рд▓рд┐рдВрдХреНрд╕ рд╣реИрдВ:\n\n"
    for token in batch_files_in_progress[user_id]:
        external_api_link = f"{EXTERNAL_API_BASE_URL}?return_to_bot={token}"
        
        # MarkdownV2 рдбрд┐рд╕реНрдкреНрд▓реЗ рдЯреЗрдХреНрд╕реНрдЯ рдХреЗ рд▓рд┐рдП рд╡рд┐рд╢реЗрд╖ рдХреИрд░реЗрдХреНрдЯрд░ рдХреЛ рдПрд╕реНрдХреЗрдк рдХрд░реЗрдВ
        # рдЯреЛрдХрди рдХреЗ рдкрд╣рд▓реЗ 8 рдХреИрд░реЗрдХреНрдЯрд░ рдХреЛ рдПрд╕реНрдХреЗрдк рдХрд░реЗрдВ
        escaped_token_part = escape_markdown_v2(token[:8])
        
        # Markdown V2 рд▓рд┐рдВрдХ рдлрд╝реЙрд░реНрдореЗрдЯ: [text](<url>)
        links_text += f"ЁЯСЙ [{escaped_token_part}...](<{external_api_link}>)\n"
    
    # рдореИрд╕реЗрдЬ рднреЗрдЬреЗрдВ
    await update.callback_query.message.reply_text(
        links_text, 
        parse_mode='MarkdownV2', 
        disable_web_page_preview=True
    )
    
    del batch_files_in_progress[user_id] # рдмреИрдЪ рдХреНрд▓рд┐рдпрд░ рдХрд░реЗрдВ
    context.user_data.pop('current_mode', None) # рдореЛрдб рдХреНрд▓рд┐рдпрд░ рдХрд░реЗрдВ
    return ConversationHandler.END # рдмрд╛рддрдЪреАрдд рдЦрддреНрдо рдХрд░реЗрдВ

async def cancel_batch(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    user_id = update.effective_user.id
    if user_id in batch_files_in_progress:
        del batch_files_in_progress[user_id]
    context.user_data.pop('current_mode', None)
    await update.message.reply_text(
        "рдмреИрдЪ рдлрд╝рд╛рдЗрд▓ рдЬрдирд░реЗрд╢рди рд░рджреНрдж рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ред", 
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END


# --- General File Handler (for /link command) ---
async def handle_file(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # рдпрджрд┐ рдпреВрдЬрд╝рд░ рдмреИрдЪ рдореЛрдб рдореЗрдВ рд╣реИ, рддреЛ рдмреИрдЪ рд╣реИрдВрдбрд▓рд░ рдХреЛ рднреЗрдЬреЗрдВ
    if context.user_data.get('current_mode') == 'batch_file':
        return await handle_batch_file_received(update, context)

    # рдЕрдиреНрдпрдерд╛, рдПрдХрд▓ рдлрд╝рд╛рдЗрд▓ рдХреЗ рд░реВрдк рдореЗрдВ рдкреНрд░реЛрд╕реЗрд╕ рдХрд░реЗрдВ
    file = None
    file_type = ""
    if update.message.document:
        file = update.message.document
        file_type = "document"
    elif update.message.video:
        file = update.message.video
        file_type = "video"
    else:
        await update.message.reply_text("рдХреГрдкрдпрд╛ рдПрдХ рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рдПрдХ рд╡реАрдбрд┐рдпреЛ рднреЗрдЬреЗрдВред")
        return

    original_filename = file.file_name if file.file_name else f"unnamed_{file_type}"
    user_chat_id = update.message.chat_id

    try:
        sent_message = await context.bot.forward_message(
            chat_id=PUBLIC_CHANNEL_ID,
            from_chat_id=user_chat_id,
            message_id=update.message.message_id
        )
        permanent_telegram_file_id = None
        if sent_message.document:
            permanent_telegram_file_id = sent_message.document.file_id
        elif sent_message.video:
            permanent_telegram_file_id = sent_message.video.file_id
        
        if not permanent_telegram_file_id:
            await update.message.reply_text("рдлрд╝реЙрд░рд╡рд░реНрдбреЗрдб рдореИрд╕реЗрдЬ рд╕реЗ рдлрд╝рд╛рдЗрд▓ ID рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред")
            return

    except Exception as e:
        await update.message.reply_text(f"рд╕реНрдЯреЛрд░реЗрдЬ рдЪреИрдирд▓ рдкрд░ рдлрд╝рд╛рдЗрд▓ рдлрд╝реЙрд░рд╡рд░реНрдб рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: {e}")
        return

    unique_token = str(uuid.uuid4())

    file_info = {
        "token": unique_token,
        "telegram_file_id": permanent_telegram_file_id,
        "original_filename": original_filename,
        "user_chat_id": user_chat_id,
        "upload_time": datetime.datetime.now(),
        "file_type": file_type
    }
    files_collection.insert_one(file_info)

    # --- рд╕рд┐рдВрдЧрд▓ рдлрд╝рд╛рдЗрд▓: рд╕реАрдзрд╛ API рд▓рд┐рдВрдХ рдкреНрд░рджрд╛рди рдХрд░реЗрдВ ---
    external_api_link = f"{EXTERNAL_API_BASE_URL}?return_to_bot={unique_token}"
    
    keyboard = [
        [InlineKeyboardButton("рдлрд╝рд╛рдЗрд▓ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ", url=external_api_link)],
        [InlineKeyboardButton("рдлрд╝рд╛рдЗрд▓ рдХреИрд╕реЗ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ", url="https://your_help_page_link.com")] # <-- рдЕрдкрдиреА рд╡рд╛рд╕реНрддрд╡рд┐рдХ рдорджрдж рдкреЗрдЬ рд▓рд┐рдВрдХ рд╕реЗ рдмрджрд▓реЗрдВ
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╕рд╣реЗрдЬреА рдЧрдИ рд╣реИ! рдЖрдЧреЗ рдмрдврд╝рдиреЗ рдФрд░ рдПрдХ рдЫреЛрдЯрд╛ рд╕рд╛ рдХрд╛рд░реНрдп рдкреВрд░рд╛ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП 'рдлрд╝рд╛рдЗрд▓ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ' рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВ:",
        reply_markup=reply_markup
    )
    context.user_data.pop('current_mode', None) # рдПрдХрд▓ рдлрд╝рд╛рдЗрд▓ рдХреЗ рдмрд╛рдж рдореЛрдб рдХреНрд▓рд┐рдпрд░ рдХрд░реЗрдВ


def main() -> None:
    # рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ рдЯреЛрдХрди, MONGO_URI, рдЖрджрд┐ рдХреЗ рд▓рд┐рдП рдкрд░реНрдпрд╛рд╡рд░рдг рдЪрд░ рд╕реЗрдЯ рд╣реИрдВ
    if not TELEGRAM_BOT_TOKEN or not MONGO_URI or not PUBLIC_CHANNEL_USERNAME or not PUBLIC_CHANNEL_ID or not EXTERNAL_API_BASE_URL:
        print("рддреНрд░реБрдЯрд┐: рдЖрд╡рд╢реНрдпрдХ рдкрд░реНрдпрд╛рд╡рд░рдг рдЪрд░ рдЧрд╛рдпрдм рд╣реИрдВред рдХреГрдкрдпрд╛ TELEGRAM_BOT_TOKEN, MONGO_URI, PUBLIC_CHANNEL_USERNAME, PUBLIC_CHANNEL_ID, EXTERNAL_API_BASE_URL рд╕реЗрдЯ рдХрд░реЗрдВред")
        exit(1) 

    # Flask рдРрдк рдХреЛ рдПрдХ рдЕрд▓рдЧ рдереНрд░реЗрдб рдореЗрдВ рдЪрд▓рд╛рдПрдВ
    # Koyeb рдкрд░ рдмреЙрдЯ рдХреА рд╣реЗрд▓реНрде рдЪреЗрдХ рдХреЗ рд▓рд┐рдП рдпрд╣ рдЖрд╡рд╢реНрдпрдХ рд╣реИ
    threading.Thread(target=run_flask_app).start()

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # --- рд╣реИрдВрдбрд▓рд░ ---
    # рд╕реНрдЯрд╛рд░реНрдЯ рдХрдорд╛рдВрдб рд╣реИрдВрдбрд▓рд░
    application.add_handler(CommandHandler("start", start))
    
    # рд╣реЗрд▓реНрдк рдФрд░ рдмреИрдХ рдмрдЯрди рдХреЗ рд▓рд┐рдП рдХреЙрд▓рдмреИрдХ рдХреНрд╡реЗрд░реА рд╣реИрдВрдбрд▓рд░
    application.add_handler(CallbackQueryHandler(help_command, pattern="^help_command$"))
    application.add_handler(CallbackQueryHandler(back_to_welcome, pattern="^back_to_welcome$"))

    # рд╕рд┐рдВрдЧрд▓ рд▓рд┐рдВрдХ рдЬрдирд░реЗрд╢рди рдХрдорд╛рдВрдб
    application.add_handler(CommandHandler("link", link_command))

    # рдмреИрдЪ рдкреНрд░реЛрд╕реЗрд╕рд┐рдВрдЧ рдХреЗ рд▓рд┐рдП рдХрдиреНрд╡рд░реНрд╕реЗрд╢рди рд╣реИрдВрдбрд▓рд░
    batch_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("batch", batch_start)],
        states={
            SENDING_BATCH_FILES: [
                MessageHandler(filters.ATTACHMENT, handle_batch_file_received),
                CallbackQueryHandler(generate_batch_links, pattern="^generate_batch_links$"),
                CommandHandler("cancel", cancel_batch) # рдпреВрдЬрд╝рд░ рдХреЛ рдмреИрдЪ рд░рджреНрдж рдХрд░рдиреЗ рдХреА рдЕрдиреБрдорддрд┐ рджреЗрдВ
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel_batch)],
    )
    application.add_handler(batch_conv_handler)

    # рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд╕рд╛рдорд╛рдиреНрдп рдореИрд╕реЗрдЬ рд╣реИрдВрдбрд▓рд░ (/link рджреНрд╡рд╛рд░рд╛ рднреА рдЙрдкрдпреЛрдЧ рдХрд┐рдпрд╛ рдЬрд╛рдПрдЧрд╛)
    # рдпрд╣ рд╣реИрдВрдбрд▓рд░ рдХреЗрд╡рд▓ рддрднреА рдЯреНрд░рд┐рдЧрд░ рд╣реЛрдЧрд╛ рдЬрдм рдХрдиреНрд╡рд░реНрд╕реЗрд╢рди рд╣реИрдВрдбрд▓рд░ рдХреА рд╕реНрдерд┐рддрд┐ рдореЗрдВ рди рд╣реЛ
    application.add_handler(MessageHandler(filters.ATTACHMENT, handle_file))

    print("рдмреЙрдЯ рдЪрд▓ рд░рд╣рд╛ рд╣реИ...")
    # Telegram рдмреЙрдЯ рдХреЛ рдкреЛрд▓рд┐рдВрдЧ рдореЛрдб рдореЗрдВ рдЪрд▓рд╛рдПрдВ
    application.run_polling(allowed_updates=Update.ALL_TYPES)

if __name__ == "__main__":
    main()
