import os
import uuid
import datetime
import logging # рд▓реЙрдЧрд┐рдВрдЧ рдХреЗ рд▓рд┐рдП рдЗрдореНрдкреЛрд░реНрдЯ рдХрд░реЗрдВ

from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application, CommandHandler, MessageHandler, filters, ContextTypes,
    ConversationHandler,
    CallbackQueryHandler 
)
from pymongo import MongoClient
from flask import Flask
import threading

# --- рд▓реЙрдЧрд┐рдВрдЧ рдХреЙрдиреНрдлрд╝рд┐рдЧрд░реЗрд╢рди ---
# рдмреЗрд╕рд┐рдХ рд▓реЙрдЧрд┐рдВрдЧ рд╕реЗрдЯ рдЕрдк рдХрд░реЗрдВ рддрд╛рдХрд┐ рдЖрдк рдмреЙрдЯ рдХреЗ рд╡реНрдпрд╡рд╣рд╛рд░ рдХреЛ рдХрдВрд╕реЛрд▓ рдореЗрдВ рджреЗрдЦ рд╕рдХреЗрдВ
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Configuration ---
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
# рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ рдпрд╣ рдЖрдкрдХреЗ PUBLIC рдЪреИрдирд▓ рдХрд╛ рдпреВрдЬрд╝рд░рдиреЗрдо рд╣реИ (рдмрд┐рдирд╛ @ рдХреЗ)
PUBLIC_CHANNEL_USERNAME = os.getenv("PUBLIC_CHANNEL_USERNAME")
# PUBLIC_CHANNEL_ID рдХреЛ рд╣рдореЗрд╢рд╛ int рдореЗрдВ рдмрджрд▓реЗрдВ
PUBLIC_CHANNEL_ID = int(os.getenv("PUBLIC_CHANNEL_ID")) 

# рдЖрдкрдХрд╛ External API (Google Apps Script) рдмреЗрд╕ URL
EXTERNAL_API_BASE_URL = os.getenv("EXTERNAL_API_BASE_URL") # <-- рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ Koyeb рдкрд░ рдпрд╣ ENV VAR рд╕реЗрдЯ рд╣реИ!

# рдЖрдкрдХрд╛ Updates Channel Link (рдЖрдкрдХреЗ рджреНрд╡рд╛рд░рд╛ рдкреНрд░рджрд╛рди рдХрд┐рдпрд╛ рдЧрдпрд╛)
UPDATES_CHANNEL_LINK = "https://t.me/asbhai_bsr" 

# MongoDB Configuration
MONGO_URI = os.getenv("MONGO_URI")
client = MongoClient(MONGO_URI)
db = client.file_bot # рдЖрдкрдХрд╛ рдбреЗрдЯрд╛рдмреЗрд╕ рдирд╛рдо
files_collection = db.files # рдЖрдкрдХрд╛ рдХрд▓реЗрдХреНрд╢рди рдирд╛рдо
# рдмреИрдЪ рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рдЕрд╕реНрдерд╛рдпреА рд╕реНрдЯреЛрд░реЗрдЬ рдкреНрд░рддрд┐ рдпреВрдЬрд╝рд░
# Key: user_id, Value: list of tokens
batch_files_in_progress = {} 

# --- Conversation States for Batch Command ---
SENDING_BATCH_FILES = 1

# --- Flask App for Health Check ---
flask_app = Flask(__name__)

@flask_app.route('/health')
def health_check():
    """
    Koyeb рдЬреИрд╕реЗ рдбрд┐рдкреНрд▓реЙрдпрдореЗрдВрдЯ рдкреНрд▓реЗрдЯрдлрд╝реЙрд░реНрдо рджреНрд╡рд╛рд░рд╛ рдЙрдкрдпреЛрдЧ рдХреЗ рд▓рд┐рдП рдПрдХ рд╕рд╛рдзрд╛рд░рдг рд╣реЗрд▓реНрде рдЪреЗрдХ рдПрдВрдбрдкреЙрдЗрдВрдЯред
    рдпрд╣ рдкреБрд╖реНрдЯрд┐ рдХрд░рддрд╛ рд╣реИ рдХрд┐ рд╡реЗрдм рд╕рд░реНрд╡рд░ рдЪрд▓ рд░рд╣рд╛ рд╣реИред
    """
    return "Bot is healthy!", 200

def run_flask_app():
    """
    Flask рдПрдкреНрд▓рд┐рдХреЗрд╢рди рдХреЛ рдПрдХ рдЕрд▓рдЧ рдереНрд░реЗрдб рдореЗрдВ рдЪрд▓рд╛рдиреЗ рдХреЗ рд▓рд┐рдП рдлрд╝рдВрдХреНрд╢рдиред
    рдпрд╣ рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░рддрд╛ рд╣реИ рдХрд┐ рдмреЙрдЯ рдХрд╛ `run_polling` рдмреНрд▓реЙрдХ рди рд╣реЛред
    """
    port = int(os.getenv("PORT", 8000))
    # Flask рдХреЛ рд╕рднреА рдЗрдВрдЯрд░рдлреЗрд╕ рдкрд░ рдЪрд▓рд╛рдПрдВ
    flask_app.run(host='0.0.0.0', port=port)
    logger.info(f"Flask health check server running on port {port}")

# --- Bot Handlers ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info(f"Received /start command from {update.effective_user.id}")
    args = context.args 

    if args:
        param = args[0]
        if param.startswith("download_"):
            original_token = param[len("download_"):]
            logger.info(f"Download deep link received for token: {original_token}")
            
            file_data = files_collection.find_one({"token": original_token})

            if file_data:
                upload_time = file_data.get("upload_time")
                if upload_time and (datetime.datetime.now() - upload_time).total_seconds() > 300: 
                    await update.message.reply_text(
                        "рдпрд╣ рдбрд╛рдЙрдирд▓реЛрдб рд▓рд┐рдВрдХ рд╕рдорд╛рдкреНрдд рд╣реЛ рдЧрдИ рд╣реИред рдХреГрдкрдпрд╛ рдПрдХ рдирдИ рд▓рд┐рдВрдХ рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рдлрд╝рд╛рдЗрд▓ рдХреЛ рдлрд┐рд░ рд╕реЗ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВред"
                    )
                    files_collection.delete_one({"token": original_token}) 
                    logger.info(f"Expired token {original_token} deleted from DB.")
                    return

                if update.effective_chat.id != file_data.get("user_chat_id"):
                    await update.message.reply_text("рдпрд╣ рдлрд╝рд╛рдЗрд▓ рдЖрдкрдХреЗ рд▓рд┐рдП рдирд╣реАрдВ рд╣реИ, рдпрд╛ рд▓рд┐рдВрдХ рдЕрдорд╛рдиреНрдп рд╣реИред")
                    logger.warning(f"Unauthorized download attempt for token {original_token} by user {update.effective_chat.id}")
                    return

                telegram_file_id = file_data["telegram_file_id"]
                original_filename = file_data["original_filename"]
                try:
                    if file_data.get("file_type") == "video": 
                        await update.message.reply_video(
                            video=telegram_file_id,
                            caption=f"рдпрд╣рд╛рдБ рдЖрдкрдХреА рд╡реАрдбрд┐рдпреЛ рд╣реИ: {original_filename}",
                            filename=original_filename
                        )
                        logger.info(f"Video {original_filename} sent to user {update.effective_chat.id}")
                    else: 
                        await update.message.reply_document(
                            document=telegram_file_id,
                            caption=f"рдпрд╣рд╛рдБ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╣реИ: {original_filename}",
                            filename=original_filename
                        )
                        logger.info(f"Document {original_filename} sent to user {update.effective_chat.id}")
                    # files_collection.delete_one({"token": original_token}) # рдпрджрд┐ рдПрдХ рдмрд╛рд░ рдбрд╛рдЙрдирд▓реЛрдб рдХреЗ рдмрд╛рдж рд╣рдЯрд╛рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВ
                except Exception as e:
                    logger.error(f"Error sending file {original_filename} to user {update.effective_chat.id}: {e}")
                    await update.message.reply_text(f"рдХреНрд╖рдорд╛ рдХрд░реЗрдВ, рдлрд╝рд╛рдЗрд▓ рдирд╣реАрдВ рднреЗрдЬреА рдЬрд╛ рд╕рдХреАред рдПрдХ рддреНрд░реБрдЯрд┐ рд╣реБрдИ: {e}")
            else:
                logger.warning(f"Invalid or expired token {original_token} requested by user {update.effective_chat.id}")
                await update.message.reply_text("рдЕрдорд╛рдиреНрдп рдпрд╛ рд╕рдорд╛рдкреНрдд рдбрд╛рдЙрдирд▓реЛрдб рдЕрдиреБрд░реЛрдзред рдХреГрдкрдпрд╛ рдкреБрдирдГ рдкреНрд░рдпрд╛рд╕ рдХрд░реЗрдВ рдпрд╛ рдПрдХ рдирдИ рдлрд╝рд╛рдЗрд▓ рдЕрдкрд▓реЛрдб рдХрд░реЗрдВред")
        else:
            await send_welcome_message(update, context) 
    else:
        await send_welcome_message(update, context)

async def send_welcome_message(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info("Sending welcome message.")
    keyboard = [
        [InlineKeyboardButton("Updates Channel", url=UPDATES_CHANNEL_LINK)],
        [InlineKeyboardButton("Help", callback_data="help_command")]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    # рдЬрд╛рдБрдЪ рдХрд░реЗрдВ рдХрд┐ рдХреНрдпрд╛ рдЕрдкрдбреЗрдЯ рдПрдХ рдореИрд╕реЗрдЬ рд╣реИ рдпрд╛ рдХреЙрд▓рдмреИрдХ рдХреНрд╡реЗрд░реА
    if update.message:
        await update.message.reply_text(
            "ЁЯСЛ рдирдорд╕реНрддреЗ! рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рд╡рд╛рд▓рд╛ рдмреЙрдЯ рд╣реВрдБред рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдпреЛрдЧреНрдп рд▓рд┐рдВрдХ рдмрдирд╛рдиреЗ рдореЗрдВ рдЖрдкрдХреА рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБред",
            reply_markup=reply_markup
        )
    elif update.callback_query:
        # рдХреЙрд▓рдмреИрдХ рдХреНрд╡реЗрд░реА рдХреЗ рд▓рд┐рдП, рдореВрд▓ рд╕рдВрджреЗрд╢ рдХреЛ рд╕рдВрдкрд╛рджрд┐рдд рдХрд░реЗрдВ
        await update.callback_query.message.edit_text(
            "ЁЯСЛ рдирдорд╕реНрддреЗ! рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рд╡рд╛рд▓рд╛ рдмреЙрдЯ рд╣реВрдБред рдореИрдВ рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдпреЛрдЧреНрдп рд▓рд┐рдВрдХ рдмрдирд╛рдиреЗ рдореЗрдВ рдЖрдкрдХреА рдорджрдж рдХрд░ рд╕рдХрддрд╛ рд╣реВрдБред",
            reply_markup=reply_markup
        )
    logger.info("Welcome message sent.")


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info("Help command received.")
    help_text = (
        "рдпрд╣рд╛рдБ рд╡реЗ рдХрдорд╛рдВрдб рджрд┐рдП рдЧрдП рд╣реИрдВ рдЬрд┐рдирдХрд╛ рдЖрдк рдЙрдкрдпреЛрдЧ рдХрд░ рд╕рдХрддреЗ рд╣реИрдВ:\n\n"
        "тЮбя╕П /start - рд╕реНрд╡рд╛рдЧрдд рд╕рдВрджреЗрд╢ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВред\n"
        "тЮбя╕П /link - рдПрдХ рдлрд╝рд╛рдЗрд▓ рдХреЗ рд▓рд┐рдП рд╕рд╛рдЭрд╛ рдХрд░рдиреЗ рдпреЛрдЧреНрдп рд▓рд┐рдВрдХ рдкреНрд░рд╛рдкреНрдд рдХрд░реЗрдВред\n"
        "тЮбя╕П /batch - рдПрдХ рд╕рд╛рде рдХрдИ рдлрд╝рд╛рдЗрд▓реЛрдВ рдХреЗ рд▓рд┐рдП рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВред\n\n"
        "рдХрдорд╛рдВрдб /link рдпрд╛ /batch рдХрд╛ рдЙрдкрдпреЛрдЧ рдХрд░рдиреЗ рдХреЗ рдмрд╛рдж рдореБрдЭреЗ рдХреЛрдИ рднреА рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рд╡реАрдбрд┐рдпреЛ рднреЗрдЬреЗрдВред"
    )
    
    if update.callback_query:
        await update.callback_query.answer() 
        chat_id = update.callback_query.message.chat_id
        message_id = update.callback_query.message.message_id
        
        await context.bot.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=help_text,
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("рдкреАрдЫреЗ", callback_data="back_to_welcome")]])
        )
        logger.info("Help message sent via callback edit.")
    else: 
        await update.message.reply_text(help_text)
        logger.info("Help message sent via direct command.")

async def back_to_welcome(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info("Back to welcome button pressed.")
    await update.callback_query.answer()
    await send_welcome_message(update, context) # welcome message will use edit_text due to update.callback_query

# --- Single File Link Generation ---
async def link_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info(f"/link command received from {update.effective_user.id}")
    context.user_data['current_mode'] = 'single_file'
    await update.message.reply_text("рдХреГрдкрдпрд╛ рдореБрдЭреЗ рд╡рд╣ рдлрд╝рд╛рдЗрд▓ (рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рд╡реАрдбрд┐рдпреЛ) рднреЗрдЬреЗрдВ рдЬрд┐рд╕рдХреА рдЖрдк рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░рдирд╛ рдЪрд╛рд╣рддреЗ рд╣реИрдВред")

# --- Batch File Link Generation ---
async def batch_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.info(f"/batch command received from {update.effective_user.id}")
    user_id = update.effective_user.id
    batch_files_in_progress[user_id] = [] 
    context.user_data['current_mode'] = 'batch_file'

    keyboard = [[InlineKeyboardButton("рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ", callback_data="generate_batch_links")]]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "рдареАрдХ рд╣реИ, рдореБрдЭреЗ рдПрдХ-рдПрдХ рдХрд░рдХреЗ рдлрд╝рд╛рдЗрд▓реЗрдВ (рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рд╡реАрдбрд┐рдпреЛ) рднреЗрдЬреЗрдВред "
        "рдЬрдм рдЖрдк рдкреВрд░рд╛ рдХрд░ рд▓реЗрдВ, рддреЛ 'рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ' рдмрдЯрди рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред",
        reply_markup=reply_markup
    )
    return SENDING_BATCH_FILES 

async def handle_batch_file_received(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    user_id = update.effective_user.id
    logger.info(f"Batch file received from {user_id}")
    if user_id not in batch_files_in_progress:
        logger.warning(f"File received for batch from {user_id} but no batch started. Falling back to single file.")
        return await handle_file(update, context) 

    file = None
    file_type = ""
    if update.message.document:
        file = update.message.document
        file_type = "document"
    elif update.message.video:
        file = update.message.video
        file_type = "video"
    else:
        logger.info(f"Unsupported file type received from {user_id} during batch.")
        await update.message.reply_text("рдХреГрдкрдпрд╛ рдПрдХ рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рдПрдХ рд╡реАрдбрд┐рдпреЛ рднреЗрдЬреЗрдВред рдЕрдиреНрдп рдлрд╝рд╛рдЗрд▓ рдкреНрд░рдХрд╛рд░ рдмреИрдЪ рдХреЗ рд▓рд┐рдП рд╕рдорд░реНрдерд┐рдд рдирд╣реАрдВ рд╣реИрдВред")
        return

    original_filename = file.file_name if file.file_name else f"unnamed_{file_type}"
    user_chat_id = update.message.chat_id

    try:
        sent_message = await context.bot.forward_message(
            chat_id=PUBLIC_CHANNEL_ID,
            from_chat_id=user_chat_id,
            message_id=update.message.message_id
        )
        permanent_telegram_file_id = None
        if sent_message.document:
            permanent_telegram_file_id = sent_message.document.file_id
        elif sent_message.video:
            permanent_telegram_file_id = sent_message.video.file_id
        
        if not permanent_telegram_file_id:
            logger.error(f"Failed to get file ID from forwarded message for file {original_filename}")
            await update.message.reply_text("рдлрд╝реЙрд░рд╡рд░реНрдбреЗрдб рдореИрд╕реЗрдЬ рд╕реЗ рдлрд╝рд╛рдЗрд▓ ID рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред")
            return

    except Exception as e:
        logger.error(f"Error forwarding file {original_filename} to storage channel: {e}")
        await update.message.reply_text(f"рд╕реНрдЯреЛрд░реЗрдЬ рдЪреИрдирд▓ рдкрд░ рдлрд╝рд╛рдЗрд▓ рдлрд╝реЙрд░рд╡рд░реНрдб рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: {e}")
        return

    unique_token = str(uuid.uuid4())

    file_info = {
        "token": unique_token,
        "telegram_file_id": permanent_telegram_file_id,
        "original_filename": original_filename,
        "user_chat_id": user_chat_id,
        "upload_time": datetime.datetime.now(),
        "file_type": file_type
    }
    files_collection.insert_one(file_info)
    logger.info(f"File {original_filename} (token: {unique_token}) saved to MongoDB.")

    batch_files_in_progress[user_id].append(unique_token)

    keyboard = [[InlineKeyboardButton("рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ", callback_data="generate_batch_links")]]
    reply_markup = InlineKeyboardMarkup(keyboard)
    await update.message.reply_text(
        "рдлрд╝рд╛рдЗрд▓ рдкреНрд░рд╛рдкреНрдд рд╣реБрдИ! рдЕрдзрд┐рдХ рдлрд╝рд╛рдЗрд▓реЗрдВ рднреЗрдЬреЗрдВ рдпрд╛ рд╕рдорд╛рдкреНрдд рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП 'рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░реЗрдВ' рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВред",
        reply_markup=reply_markup
    )
    return SENDING_BATCH_FILES 


# MarkdownV2 рд╕реНрдкреЗрд╢рд▓ рдХреИрд░реЗрдХреНрдЯрд░ рдХреЛ рдПрд╕реНрдХреЗрдк рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП рд╕рд╣рд╛рдпрдХ рдлрд╝рдВрдХреНрд╢рди
def escape_markdown_v2(text: str) -> str:
    # рдХреЗрд╡рд▓ рд╡реЗ рдХреИрд░реЗрдХреНрдЯрд░ рдПрд╕реНрдХреЗрдк рдХрд░реЗрдВ рдЬреЛ MarkdownV2 рдореЗрдВ рд╡рд┐рд╢реЗрд╖ рдЕрд░реНрде рд░рдЦрддреЗ рд╣реИрдВ
    # рдФрд░ рдЬреЛ рдЖрдкрдХреЗ literal text рдореЗрдВ рдЖ рд╕рдХрддреЗ рд╣реИрдВред
    # URL рдХреЗ рдЕрдВрджрд░ рдХреЗ рдХреИрд░реЗрдХреНрдЯрд░ рдХреЛ рдПрд╕реНрдХреЗрдк рдХрд░рдиреЗ рдХреА рдЖрд╡рд╢реНрдпрдХрддрд╛ рдирд╣реАрдВ рд╣реЛрддреА,
    # рдХреЗрд╡рд▓ рдбрд┐рд╕реНрдкреНрд▓реЗ рдЯреЗрдХреНрд╕реНрдЯ рдореЗрдВред
    escape_chars = r'_*[]()~`>#+-=|{}.!' 
    return ''.join(['\\' + char if char in escape_chars else char for char in text])


async def generate_batch_links(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    logger.info(f"Generate batch links button pressed by {update.effective_user.id}")
    await update.callback_query.answer("рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░ рд░рд╣рд╛ рд╣реВрдБ...")
    user_id = update.effective_user.id
    
    if user_id not in batch_files_in_progress or not batch_files_in_progress[user_id]:
        await update.callback_query.message.reply_text("рдХреЛрдИ рдлрд╝рд╛рдЗрд▓реЗрдВ рдирд╣реАрдВ рдорд┐рд▓реАрдВ рдЬрд┐рдирдХреЗ рд▓рд┐рдП рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХреА рдЬрд╛ рд╕рдХреЗрдВред рдХреГрдкрдпрд╛ рдкрд╣рд▓реЗ рдлрд╝рд╛рдЗрд▓реЗрдВ рднреЗрдЬреЗрдВред")
        logger.warning(f"Generate batch links pressed but no files in progress for user {user_id}")
        return ConversationHandler.END 
    
    links_text = "рдпрд╣рд╛рдБ рдЖрдкрдХреА рдбрд╛рдЙрдирд▓реЛрдб рд▓рд┐рдВрдХреНрд╕ рд╣реИрдВ:\n\n"
    
    for token in batch_files_in_progress[user_id]:
        external_api_link = f"{EXTERNAL_API_BASE_URL}?return_to_bot={token}"
        
        # рдбрд┐рд╕реНрдкреНрд▓реЗ рдЯреЗрдХреНрд╕реНрдЯ рдореЗрдВ рдЯреЛрдХрди рдХреЗ рдкрд╣рд▓реЗ 8 рдХреИрд░реЗрдХреНрдЯрд░ рдХреЛ рдПрд╕реНрдХреЗрдк рдХрд░реЗрдВ рдФрд░ "..." рдХреЛ рднреА
        display_text = escape_markdown_v2(token[:8]) + escape_markdown_v2("...")
        
        links_text += f"ЁЯСЙ [{display_text}](<{external_api_link}>)\n"
    
    try:
        await update.callback_query.message.reply_text(
            links_text, 
            parse_mode='MarkdownV2', 
            disable_web_page_preview=True
        )
        logger.info(f"Batch links sent to user {user_id}")
    except telegram.error.BadRequest as e:
        logger.error(f"Error sending MarkdownV2 batch links to user {user_id}: {e}")
        # рдпрджрд┐ рдЕрднреА рднреА рдХреЛрдИ рдкрд╛рд░реНрд╕рд┐рдВрдЧ рдПрд░рд░ рдЖрддреА рд╣реИ, рддреЛ рдмрд┐рдирд╛ Markdown рдХреЗ рднреЗрдЬреЗрдВ
        fallback_links_text = "рд▓рд┐рдВрдХ рдЬрдирд░реЗрдЯ рдХрд░рдиреЗ рдореЗрдВ рд╕рдорд╕реНрдпрд╛ рд╣реБрдИред рдпрд╣рд╛рдБ рд░реЙ рд▓рд┐рдВрдХреНрд╕ рд╣реИрдВ:\n\n" + \
                              "\n".join([f"ЁЯСЙ {EXTERNAL_API_BASE_URL}?return_to_bot={t}" 
                                         for t in batch_files_in_progress[user_id]])
        await update.callback_query.message.reply_text(fallback_links_text)
    
    del batch_files_in_progress[user_id] 
    context.user_data.pop('current_mode', None) 
    return ConversationHandler.END 

async def cancel_batch(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    logger.info(f"Batch cancelled by {update.effective_user.id}")
    user_id = update.effective_user.id
    if user_id in batch_files_in_progress:
        del batch_files_in_progress[user_id]
    context.user_data.pop('current_mode', None)
    await update.message.reply_text(
        "рдмреИрдЪ рдлрд╝рд╛рдЗрд▓ рдЬрдирд░реЗрд╢рди рд░рджреНрдж рдХрд░ рджрд┐рдпрд╛ рдЧрдпрд╛ред", 
        reply_markup=ReplyKeyboardRemove()
    )
    return ConversationHandler.END


# --- General File Handler (for /link command or fallback) ---
async def handle_file(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    # рдпрджрд┐ рдпреВрдЬрд╝рд░ рдмреИрдЪ рдореЛрдб рдореЗрдВ рд╣реИ, рддреЛ рдмреИрдЪ рд╣реИрдВрдбрд▓рд░ рдХреЛ рднреЗрдЬреЗрдВ
    if context.user_data.get('current_mode') == 'batch_file':
        logger.info(f"File received in batch mode from {update.effective_user.id}. Passing to batch handler.")
        return await handle_batch_file_received(update, context)

    logger.info(f"Single file received from {update.effective_user.id}")
    file = None
    file_type = ""
    if update.message.document:
        file = update.message.document
        file_type = "document"
    elif update.message.video:
        file = update.message.video
        file_type = "video"
    else:
        logger.info(f"Unsupported file type received from {update.effective_user.id} in single mode.")
        await update.message.reply_text("рдХреГрдкрдпрд╛ рдПрдХ рдбреЙрдХреНрдпреВрдореЗрдВрдЯ рдпрд╛ рдПрдХ рд╡реАрдбрд┐рдпреЛ рднреЗрдЬреЗрдВред")
        return

    original_filename = file.file_name if file.file_name else f"unnamed_{file_type}"
    user_chat_id = update.message.chat_id

    try:
        sent_message = await context.bot.forward_message(
            chat_id=PUBLIC_CHANNEL_ID,
            from_chat_id=user_chat_id,
            message_id=update.message.message_id
        )
        permanent_telegram_file_id = None
        if sent_message.document:
            permanent_telegram_file_id = sent_message.document.file_id
        elif sent_message.video:
            permanent_telegram_file_id = sent_message.video.file_id
        
        if not permanent_telegram_file_id:
            logger.error(f"Failed to get file ID from forwarded message for single file {original_filename}")
            await update.message.reply_text("рдлрд╝реЙрд░рд╡рд░реНрдбреЗрдб рдореИрд╕реЗрдЬ рд╕реЗ рдлрд╝рд╛рдЗрд▓ ID рдкреНрд░рд╛рдкреНрдд рдХрд░рдиреЗ рдореЗрдВ рд╡рд┐рдлрд▓ред")
            return

    except Exception as e:
        logger.error(f"Error forwarding single file {original_filename} to storage channel: {e}")
        await update.message.reply_text(f"рд╕реНрдЯреЛрд░реЗрдЬ рдЪреИрдирд▓ рдкрд░ рдлрд╝рд╛рдЗрд▓ рдлрд╝реЙрд░рд╡рд░реНрдб рдХрд░рдиреЗ рдореЗрдВ рддреНрд░реБрдЯрд┐: {e}")
        return

    unique_token = str(uuid.uuid4())

    file_info = {
        "token": unique_token,
        "telegram_file_id": permanent_telegram_file_id,
        "original_filename": original_filename,
        "user_chat_id": user_chat_id,
        "upload_time": datetime.datetime.now(),
        "file_type": file_type
    }
    files_collection.insert_one(file_info)
    logger.info(f"Single file {original_filename} (token: {unique_token}) saved to MongoDB.")

    external_api_link = f"{EXTERNAL_API_BASE_URL}?return_to_bot={unique_token}"
    
    keyboard = [
        [InlineKeyboardButton("рдлрд╝рд╛рдЗрд▓ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ", url=external_api_link)],
        [InlineKeyboardButton("рдлрд╝рд╛рдЗрд▓ рдХреИрд╕реЗ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ", url="https://your_help_page_link.com")] # <-- рдЕрдкрдиреА рд╡рд╛рд╕реНрддрд╡рд┐рдХ рдорджрдж рдкреЗрдЬ рд▓рд┐рдВрдХ рд╕реЗ рдмрджрд▓реЗрдВ
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)

    await update.message.reply_text(
        "рдЖрдкрдХреА рдлрд╝рд╛рдЗрд▓ рд╕рд╣реЗрдЬреА рдЧрдИ рд╣реИ! рдЖрдЧреЗ рдмрдврд╝рдиреЗ рдФрд░ рдПрдХ рдЫреЛрдЯрд╛ рд╕рд╛ рдХрд╛рд░реНрдп рдкреВрд░рд╛ рдХрд░рдиреЗ рдХреЗ рд▓рд┐рдП 'рдлрд╝рд╛рдЗрд▓ рдбрд╛рдЙрдирд▓реЛрдб рдХрд░реЗрдВ' рдкрд░ рдХреНрд▓рд┐рдХ рдХрд░реЗрдВ:",
        reply_markup=reply_markup
    )
    context.user_data.pop('current_mode', None) 


def main() -> None:
    # рд╕реБрдирд┐рд╢реНрдЪрд┐рдд рдХрд░реЗрдВ рдХрд┐ рд╕рднреА рдЖрд╡рд╢реНрдпрдХ рдкрд░реНрдпрд╛рд╡рд░рдг рдЪрд░ рд╕реЗрдЯ рд╣реИрдВ
    required_env_vars = ["TELEGRAM_BOT_TOKEN", "MONGO_URI", "PUBLIC_CHANNEL_USERNAME", "PUBLIC_CHANNEL_ID", "EXTERNAL_API_BASE_URL"]
    for var in required_env_vars:
        if not os.getenv(var):
            logger.error(f"рддреНрд░реБрдЯрд┐: рдЖрд╡рд╢реНрдпрдХ рдкрд░реНрдпрд╛рд╡рд░рдг рдЪрд░ '{var}' рдЧрд╛рдпрдм рд╣реИред рдХреГрдкрдпрд╛ рдЗрд╕реЗ рд╕реЗрдЯ рдХрд░реЗрдВред")
            exit(1) # рдпрджрд┐ рдХреЛрдИ рдорд╣рддреНрд╡рдкреВрд░реНрдг рдЪрд░ рдЧрд╛рдпрдм рд╣реИ рддреЛ рдмрд╛рд╣рд░ рдирд┐рдХрд▓реЗрдВ

    # Flask рдРрдк рдХреЛ рдПрдХ рдЕрд▓рдЧ рдереНрд░реЗрдб рдореЗрдВ рдЪрд▓рд╛рдПрдВ
    threading.Thread(target=run_flask_app).start()

    application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()

    # --- рд╣реИрдВрдбрд▓рд░ ---
    application.add_handler(CommandHandler("start", start))
    
    application.add_handler(CallbackQueryHandler(help_command, pattern="^help_command$"))
    application.add_handler(CallbackQueryHandler(back_to_welcome, pattern="^back_to_welcome$"))

    application.add_handler(CommandHandler("link", link_command))

    batch_conv_handler = ConversationHandler(
        entry_points=[CommandHandler("batch", batch_start)],
        states={
            SENDING_BATCH_FILES: [
                MessageHandler(filters.ATTACHMENT, handle_batch_file_received),
                CallbackQueryHandler(generate_batch_links, pattern="^generate_batch_links$"),
                CommandHandler("cancel", cancel_batch) 
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel_batch)],
    )
    application.add_handler(batch_conv_handler)

    application.add_handler(MessageHandler(filters.ATTACHMENT, handle_file))

    logger.info("рдмреЙрдЯ рдЪрд▓ рд░рд╣рд╛ рд╣реИ...")
    # Telegram рдмреЙрдЯ рдХреЛ рдкреЛрд▓рд┐рдВрдЧ рдореЛрдб рдореЗрдВ рдЪрд▓рд╛рдПрдВ
    # allowed_updates=Update.ALL_TYPES рдХреЛ рд╣рдЯрд╛рдирд╛ рдЕрдХреНрд╕рд░ Conflict рдПрд░рд░ рдХреЛ рдХрдо рдХрд░рдиреЗ рдореЗрдВ рдорджрдж рдХрд░рддрд╛ рд╣реИ
    application.run_polling() # removed allowed_updates=Update.ALL_TYPES

if __name__ == "__main__":
    main()
